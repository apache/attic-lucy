/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef CORE_H
#define CORE_H

#include <stdint.h>
#include <stddef.h>

// Generic method pointer.
typedef void
(*method_t)(void *self);

/** Boostrap the core.
 */
void
Core_bootstrap(void);

/** Clean up after Core_bootstrap().
 */
void
Core_tear_down(void);

/** Base object type.
 */
typedef struct Object Object;

/** Destructor.
 */
typedef void 
(*Obj_destroy_t)(Object *self);
extern uint64_t Obj_destroy_OFFSETS;
static inline void
Obj_destroy(Object *self) {
    const uint64_t offsets = Obj_destroy_OFFSETS;
    void *const view = (char*)self + (int32_t)(offsets >> 32);
    char *const method_address = *(char**)self + (uint32_t)offsets;
    Obj_destroy_t method = *((Obj_destroy_t*)method_address);
    method(view);
}

/** Class data, including virtual method table.
 */
typedef struct MetaClass MetaClass;

// Core MetaClasses.
extern MetaClass *cMETACLASS;
extern MetaClass *cOBJECT;

static inline method_t
MetaClass_method_pointer(MetaClass *self, int64_t offsets) {
    char *const method_address = *(char**)self + (uint32_t)offsets;
    return *((method_t*)method_address);
}

/** Constructor.
 */
MetaClass*
MetaClass_new(MetaClass *superclass, const char *name, size_t obj_alloc_size,
              size_t num_methods);

/** Destructor.
 */
typedef void 
(*MetaClass_destroy_t)(MetaClass *self);
extern uint64_t MetaClass_destroy_OFFSETS;
static inline void
MetaClass_destroy(MetaClass *self) {
    const uint64_t offsets = MetaClass_destroy_OFFSETS;
    void *const view = (char*)self + (int32_t)(offsets >> 32);
    char *const method_address = *(char**)self + (uint32_t)offsets;
    MetaClass_destroy_t method = *((MetaClass_destroy_t*)method_address);
    method(view);
}

/** Allocate a new object.
 */
typedef void*
(*MetaClass_make_obj_t)(MetaClass *self);
extern uint64_t MetaClass_make_obj_OFFSETS;
static inline void*
MetaClass_make_obj(MetaClass *self) {
    const uint64_t offsets = MetaClass_make_obj_OFFSETS;
    void *const view = (char*)self + (int32_t)(offsets >> 32);
    char *const method_address = *(char**)self + (uint32_t)offsets;
    MetaClass_make_obj_t method = *((MetaClass_make_obj_t*)method_address);
    return method(view);
}

/** Add a new method to the MetaClass.  Return the offsets data needed to invoke
 * the method.
 */
typedef uint64_t
(*MetaClass_add_novel_method_t)(MetaClass *self, method_t method);
extern uint64_t MetaClass_add_novel_method_OFFSETS;
static inline uint64_t
MetaClass_add_novel_method(MetaClass *self, method_t method) {
    const uint64_t offsets = MetaClass_add_novel_method_OFFSETS;
    void *const view = (char*)self + (int32_t)(offsets >> 32);
    char *const method_address = *(char**)self + (uint32_t)offsets;
    MetaClass_add_novel_method_t meth = *((MetaClass_add_novel_method_t*)method_address);
    return meth(view, method);
}

/** Override an existing method, installing <code>method</code> at the
 * location specified by <code>offsets</code>.  Return the offsets data needed
 * to invoke the method.
 */
typedef uint64_t 
(*MetaClass_override_method_t)(MetaClass *self, method_t method, uint64_t offsets);
extern uint64_t MetaClass_override_method_OFFSETS;
static inline uint64_t
MetaClass_override_method(MetaClass *self, method_t method, uint64_t offsets) {
    const uint64_t offs = MetaClass_override_method_OFFSETS;
    void *const view = (char*)self + (int32_t)(offs >> 32);
    char *const method_address = *(char**)self + (uint32_t)offs;
    MetaClass_override_method_t meth = *((MetaClass_override_method_t*)method_address);
    return meth(view, method, offsets);
}

/** Inherit a method from a parent class and generate the necessary offset
 * invocation data.
 *
 * NOTE: This task will be performed by autogenerated code in production.
 */
typedef uint64_t
(*MetaClass_inherit_method_t)(MetaClass *self, uint64_t offsets);
extern uint64_t MetaClass_inherit_method_OFFSETS;
static inline uint64_t
MetaClass_inherit_method(MetaClass *self, uint64_t offsets) {
    const uint64_t offs = MetaClass_inherit_method_OFFSETS;
    void *const view = (char*)self + (int32_t)(offs >> 32);
    char *const method_address = *(char**)self + (uint32_t)offs;
    MetaClass_inherit_method_t method = *((MetaClass_inherit_method_t*)method_address);
    return method(view, offsets);
}

/** Return the number of methods that the VTable will have when it is
 * finished initializing.
 */
typedef size_t
(*MetaClass_get_num_methods_t)(MetaClass *self);
extern uint64_t MetaClass_get_num_methods_OFFSETS;
static inline size_t 
MetaClass_get_num_methods(MetaClass *self) {
    const uint64_t offsets = MetaClass_get_num_methods_OFFSETS;
    void *const view = (char*)self + (int32_t)(offsets >> 32);
    char *const method_address = *(char**)self + (uint32_t)offsets;
    MetaClass_get_num_methods_t method = *((MetaClass_get_num_methods_t*)method_address);
    return method(view);
}

/** Return the size of the an object belonging to the specified class.
 */
typedef size_t
(*MetaClass_get_obj_alloc_size_t)(MetaClass *self);
extern uint64_t MetaClass_get_obj_alloc_size_OFFSETS;
static inline size_t 
MetaClass_get_obj_alloc_size(MetaClass *self) {
    const uint64_t offsets = MetaClass_get_obj_alloc_size_OFFSETS;
    void *const view = (char*)self + (int32_t)(offsets >> 32);
    char *const method_address = *(char**)self + (uint32_t)offsets;
    MetaClass_get_obj_alloc_size_t method = *((MetaClass_get_obj_alloc_size_t*)method_address);
    return method(view);
}

#endif /* CORE_H */

